% Karis Mao, Jack Shapiro, Lillian Kagy, Trevor Swan
% ENGR 130 Module 5.1 Report
% Section E
% November 5, 2023

%% Lab 1 report
clc;
clear;
close all;

% Define the time step and time vector
dt = 1/1024;
time = 0:dt:(1-dt);

% Define given Amplitude and Frequency Vectors
amplitudes = [1 20 5 3 17 1.5];
frequencies = [12 17 20 5 15 5];
y_comp = getComposite(frequencies, amplitudes, time);

% Perform the fourrier transform of y_comp
[f_comp, Y_comp] = ENGR130_Fourier(time, y_comp);

% Graph the Data obtained from the fourrier transform in a stem plot
figure()
stem(f_comp, Y_comp)
xlim([0,30])
title("Frequency-Domain Graph of Summed Sinusoidal Signals")
xlabel('Frequencies(Hz)')
ylabel('Amplitude')

% Loads the mystery signal and inputs it into the fourier transform function
load("mystery_signal.mat");
[f,y] = ENGR130_Fourier(time, mystery);

% Plotting mystery vs time and y vs f on the same image
figure();
subplot(2,1,1);

% Plotting mystery vs time and labeling graph
plot(time, mystery);
xlabel("Time (s)")
ylabel("Mystery Signal")
title("Graph of The Mystery Signal Over Time")
subplot(2,1,2);

% Plotting y vs f and labeling the graph
stem(f,y);
xlim([0,405]);
ylim([0,11])
xlabel("Frequency (Hz)")
ylabel("Amplitude")
title("Amplitude vs Frequency after Fourier Transform")

% Inputs the f and y values into getComponentParams to return them as a
% matrix
fymatrix = getComponentParams(f, y);

% separate the matrix into separate columns
f2 = fymatrix(:, 1);
y2 = fymatrix(:, 2);

% find the values y2 that are greater than 4 through logical indexing and 
% find the correspoding frequencies 
f2 = f2(y2 > 4);
y2 = y2(y2 > 4);
composite = getComposite(f2, y2, time);

% Seperating the noise and Plotting it
figure();
new_signal = mystery - composite;
plot(time, new_signal);
xlabel("time (s)")
ylabel("Amplitude")
title("Noise")

%% Functions
function y = getSinusoid(f, A, t)
% This function generates a Sinusoidal Graph using a provided equation and based on given data
% Format of call getSinusoid(f, A, t)
% Inputs - 3 values
%       f - frequency value, A - amplitude value, t - time vector
% Output - 1 value
%       y - sinusoidal signal vector 

y = A * sin(2*pi*f.*t);
end

function composite = getComposite(frequencies, amplitudes, time)
% This function adds sinusoidal signals together into one composite signal
% Format of call getComposite(frequencies, amplitudes, time)
% Inputs - 3 values
%       frequencies - frequency vector
%       amplitudes - amplitde vector
%       time - time vector
% Note - frequency and aplitude vectors must be the same size
% Output - 1 value
%       composite - composite signal vector

% prevent the function from running if the vector sizes are different
if numel(frequencies) ~= numel(amplitudes)
    error('Your frequency and amplitude functions are different lengths!')
end

% initialize the composite vector
composite = zeros(1,numel(time));

% loop through the frequency and amplitude vectors, calling the getSinusoid
% function to gather a sinusoid signal for each pair of values.
for idx = 1: numel(frequencies)
    % sum all of the sinusoid signals together as the loop continues
    composite = composite + getSinusoid(frequencies(idx), amplitudes(idx), time);
end
end

function [matrix] = getComponentParams(f, y)
% This function takes in frequencies and amplitudes and returns them in a
% matrix
% Call format: getComponentParams(frequencies,amplitudes)
% Inputs: vectors of frequencies and amplitudes of the same length
% Output: a matrix where the first column is the frequencies and the second
% is the amplitudes
matrix = [];
for indx = 1:length(f)
    matrix(indx,1)= f(indx);
    matrix(indx,2)=y(indx);
end
end

function [f, Y] = ENGR130_Fourier(t, signal)
%ENGR130_Fourier uses Matlab's fft() function together with additional
%post-processing steps to convert from time to frequency domain for an
%input signal.
%
% Syntax:
%   [f, Y] = ENGR130_Fourier(t, signal) 
%
% Inputs:
%    t      - A time vector with uniform stepsize (likely generated by MATLAB
%             or collected by the oscilloscope
%    signal - The corresponding voltage values for each point in t.
%             This array must be the same size as t_in.
%
% Outputs:
%    f     - A frequency vector corresponding to the fft of signal
%    Y     - The amplitude contributions at each frequency f.
%
% Example Usage:
%   [frequency, Amplitude] = ENGR130_Fourier(time, Voltage_collected)

% Nov 2020; Last revision: Rhoads 10-28-2022
%
%------------- BEGIN CODE --------------

% Change column vectors to row vectors
[rows, ~] = size(signal);
if rows > 1
    signal = signal';
    t = t';
end

% Look for poor importing (Titles, names, not numbers...)
t_new = t(~isnan(t));

shift = length(t) - length(t_new);
t = t_new - min(t_new);
signal = signal(1:end - shift);

% define dt for given time step
dt = t(2) - t(1);

% create time vector for given time
xq = 0:dt:max(t);

% Have to get unique points out of the way,
%    although there should be none.
[time_u, index] = unique(t); 
vq = interp1(time_u, signal(index), xq);

% If the data doesn't start right away, there are issues
% Specifically, NaN shows up and clutters the DC Offset
signal = vq(~isnan(vq));

% Starting to do the Fourier transform
N = length(signal);

% define sampling frequency, Hz
fs = 1/dt;

% We need an even number of samples, so just chop off the excess
if rem(N, 2) ~= 0
    signal = signal(1:end-1);
end

% total number of samples
N = length(signal);

% discrete Fourier transform
Y = fft(signal);

% create the frequency variable
f = fs/N * (0:N/2);

% shorten DFT to only half of the values (positive Frequencies)
Y = Y(1:N/2+1);

% Normalize the Fourier transform, take absolute magnitude
Y = abs(Y)/N;

% correct normalization b/c only using half the frequncies.
Y(2:end) = 2 * Y(2:end);


end